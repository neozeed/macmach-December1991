Info file gdb.info, produced by Makeinfo, -*- Text -*- from input
file gdb-all.texinfo.

   This file documents the GNU debugger GDB.

   Copyright (C) 1988, 1989, 1990, 1991 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of
this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for
modified versions, except that the section entitled "GNU General
Public License" may be included in a translation approved by the
Free Software Foundation instead of in the original English.


File: gdb.info,  Node: Files,  Next: Symbol Errors,  Prev: GDB Files,  Up: GDB Files

Commands to Specify Files
=========================

   GDB needs to know the file name of the program to be debugged,
both in order to read its symbol table and in order to start the
program.  To debug a core dump of a previous run, GDB must be told
the file name of the core dump.

   The usual way to specify the executable and core dump file names
is with the command arguments given when you start GDB, as discussed
in *note Invocation::..

   Occasionally it is necessary to change to a different file during
a GDB session.  Or you may run GDB and forget to specify the files
you want to use.  In these situations the GDB commands to specify
new files are useful.

`file FILENAME'
     Use FILENAME as the program to be debugged.  It is read for its
     symbols and for the contents of pure memory.  It is also the
     program executed when you use the `run' command.  If you do not
     specify a directory and the file is not found in GDB's working
     directory,

     GDB uses the environment variable `PATH' as a list of
     directories to search, just as the shell does when looking for
     a
     program to run.  You can change the value of this variable, for
     both GDB and your program, using the `path' command.

     `file' with no argument makes GDB discard any information it has
     on both executable file and the symbol table.

`exec-file FILENAME'
     Specify that the program to be run (but not the symbol table) is
     found in FILENAME.  GDB will search the environment variable
     `PATH' if necessary to locate the program.

`symbol-file FILENAME'
     Read symbol table information from file FILENAME.  `PATH' is
     searched when necessary.  Use the `file' command to get both
     symbol table and program to run from the same file.

     `symbol-file' with no argument clears out GDB's information on
     your program's symbol table.

     The `symbol-file' command causes GDB to forget the contents of
     its convenience variables, the value history, and all
     breakpoints and auto-display expressions.  This is because they
    
     may contain pointers to the internal data recording symbols and
     data types, which are part of the old symbol table data being
     discarded inside GDB.

     `symbol-file' will not repeat if you press RET again after
     executing it once.

     On some kinds of object files, the `symbol-file' command does
     not actually read the symbol table in full right away. 
     Instead, it scans the symbol table quickly to find which source
     files and which symbols are present.  The details are read
     later, one source file at a time, when they are needed.

     The purpose of this two-stage reading strategy is to make GDB
     start up faster.  For the most part, it is invisible except for
     occasional pauses while the symbol table details for a
     particular source file are being read.  (The `set verbose'
     command can turn these pauses into messages if desired. *Note
     Messages/Warnings::).

     When the symbol table is stored in COFF format, `symbol-file'
     does read the symbol table data in full right away.  We haven't
     implemented the two-stage strategy for COFF yet.

     When GDB is configured for a particular environment, it will
     understand debugging information in whatever format is the
     standard generated for that environment; you may use either a
     GNU compiler, or other compilers that adhere to the local
     conventions.  Best results are usually obtained from GNU
     compilers; for example, using `gcc' you can generate debugging
     information for optimized code.

`core-file FILENAME'
`core FILENAME'
     Specify the whereabouts of a core dump file to be used as the
     "contents of memory".  Traditionally, core files contain only
     some parts of the address space of the process that generated
     them; GDB can access the executable file itself for other parts.

     `core-file' with no argument specifies that no core file is to
     be used.

     Note that the core file is ignored when your program is actually
     running under GDB.  So, if you have been running the program
     and you wish to debug a core file instead, you must kill the
     subprocess in which the program is running.  To do this, use
     the `kill' command (*note Kill Process::.).

`load FILENAME'
     Depending on what remote debugging facilities are configured
     into GDB, the `load' command may be available.  Where it
     exists, it is meant to make FILENAME (an executable) available
     for debugging on the remote system--by downloading, or dynamic
     linking, for example.  `load' also records FILENAME's symbol
     table in GDB, like the `add-symbol-file' command.

     If `load' is not available on your GDB, attempting to execute it
     gets the error message "`You can't do that when your target is
     ...'"

     On VxWorks, `load' will dynamically link FILENAME on the current
     target system as well as adding its symbols in GDB.

     With the Nindy interface to an Intel 960 board, `load' will
     download FILENAME to the 960 as well as adding its symbols in
     GDB.

     `load' will not repeat if you press RET again after using it.

`add-symbol-file FILENAME ADDRESS'
     The `add-symbol-file' command reads additional symbol table
     information from the file FILENAME.  You would use this command
     when that file has been dynamically loaded (by some other
     means) into the program that is running.  ADDRESS should be the
     memory address at which the file has been loaded; GDB cannot
     figure this out for itself.

     The symbol table of the file FILENAME is added to the symbol
     table originally read with the `symbol-file' command.  You can
     use the `add-symbol-file' command any number of times; the new
     symbol data thus read keeps adding to the old.  To discard all
     old symbol data instead, use the `symbol-file' command.

     `add-symbol-file' will not repeat if you press RET after using it.

`info files'
`info target'
     `info files' and `info target' are synonymous; both print the
     current targets (*note Targets::.), including the names of the
     executable and core dump files currently in use by GDB, and the
     files from which symbols were loaded.  The command `help
     targets' lists all possible targets rather than current ones.

   All file-specifying commands allow both absolute and relative file
names as arguments.  GDB always converts the file name to an
absolute path name and remembers it that way.

   GDB supports the SunOS shared library format.  Symbols from a
shared library cannot be referenced before the shared library has
been linked with the program.  (That is to say, until after you type
`run' and  the function `main' has been entered; or when examining
core files.)  Once the shared library has been linked in, you can
use the following commands:

`sharedlibrary REGEX'
`share REGEX'
     Load shared object library symbols for files matching a UNIX
     regular expression.

`share'
`sharedlibrary'
     Load symbols for all shared libraries.

`info share'
`info sharedlibrary'
     Print the names of the shared libraries which you have loaded
     with the `sharedlibrary' command.

   `sharedlibrary' does not repeat automatically when you press RET
after using it once.


File: gdb.info,  Node: Symbol Errors,  Prev: Files,  Up: GDB Files

Errors Reading Symbol Files
===========================

   While a symbol file is being read, GDB will occasionally encounter
problems, such as symbol types it does not recognize, or known bugs
in compiler output.  By default, it prints one message about each
such type of problem, no matter how many times the problem occurs. 
You can ask it to print more messages, to see how many times the
problems occur, or can shut the messages off entirely, with the `set
complaints' command (*Note Messages/Warnings::).

   The messages currently printed, and their meanings, are:

`inner block not inside outer block in SYMBOL'
     The symbol information shows where symbol scopes begin and end
     (such as at the start of a function or a block of statements). 
     This error indicates that an inner scope block is not fully
     contained in its outer scope blocks.

     GDB circumvents the problem by treating the inner block as if it
     had the same scope as the outer block.  In the error message,
     SYMBOL may be shown as "`(don't know)'" if the outer block is
     not a function.

`block at ADDRESS out of order'
     The symbol information for symbol scope blocks should occur in 
     order of increasing addresses.  This error indicates that it
     does not do so.

     GDB does not circumvent this problem, and will have trouble
     locating symbols in the source file whose symbols being read. 
     (You can often determine what source file is affected by
     specifying `set verbose on'.  *Note Messages/Warnings::.)

`bad block start address patched'
     The symbol information for a symbol scope block has a start
     address smaller than the address of the preceding source line. 
     This is known to occur in the SunOS 4.1.1 (and earlier) C
     compiler.

     GDB circumvents the problem by treating the symbol scope block
     as starting on the previous source line.

`bad string table offset in symbol N'
     Symbol number N contains a pointer into the string table which
     is larger than the size of the string table.

     GDB circumvents the problem by considering the symbol to have
     the name `foo', which may cause other problems if many symbols
     end up with this name.

`unknown symbol type `0xNN''
     The symbol information contains new data types that GDB does not
     yet know how to read.  `0xNN' is the symbol type of the
     misunderstood information, in hexadecimal.

     GDB circumvents the error by ignoring this symbol information. 
     This will usually allow the program to be debugged, though
     certain symbols will not be accessible.  If you encounter such
     a problem and feel like debugging it, you can debug `gdb' with
     itself, breakpoint on `complain', then go up to the function
     `read_dbx_symtab' and examine `*bufp' to see the symbol.

`stub type has NULL name'
     GDB could not find the full definition for a struct or class.

`C++ type mismatch between compiler and debugger'
     GDB could not parse a type specification output by the compiler
     for some C++ object.


File: gdb.info,  Node: Targets,  Next: Controlling GDB,  Prev: GDB Files,  Up: Top

Specifying a Debugging Target
*****************************

   A "target" is an interface between the debugger and a particular 
kind of file or process.

   Often, you will be able to run GDB in the same host environment as
the program you are debugging; in that case, the debugging target
can just be specified as a side effect of the `file' or `core'
commands.  When you need more flexibility--for example, running GDB
on a physically separate host, controlling standalone systems over a
serial port, or realtime systems over a TCP/IP connection--you can
use the `target' command.

* Menu:

* Active Targets::		Active Targets
* Target Commands::		Commands for Managing Targets
* Remote::			Remote Debugging


File: gdb.info,  Node: Active Targets,  Next: Target Commands,  Prev: Targets,  Up: Targets

Active Targets
==============

   Targets are managed in three "strata" that correspond to different
classes of target: processes, core files, and executable files. 
This allows you to (for example) start a process and inspect its
activity without abandoning your work on a core file.

   More than one target can potentially respond to a request.  In
particular, when you access memory GDB will examine the three strata
of targets until it finds a target that can handle that particular
address.  Strata are always examined in a fixed order: first a
process if there is one, then a core file if there is one, and
finally
an executable file if there is one of those.

   When you specify a new target in a given stratum, it replaces any
target previously in that stratum.

   To get rid of a target without replacing it, use the `detach'
command.  The related command `attach' provides you with a way of
choosing a particular running process as a new target. *Note Attach::.


File: gdb.info,  Node: Target Commands,  Next: Remote,  Prev: Active Targets,  Up: Targets

Commands for Managing Targets
=============================

`target TYPE PARAMETERS'
     Connects the GDB host environment to a target machine or
     process.  A target is typically a protocol for talking to
     debugging facilities.  You use the argument TYPE to specify the
     type or protocol of the target machine.

     Further PARAMETERS are interpreted by the target protocol, but
     typically include things like device names or host names to
     connect with, process numbers, and baud rates.

     The `target' command will not repeat if you press RET again
     after executing the command.

`help target'
     Displays the names of all targets available.  To display targets
     currently selected, use either `info target' or `info files'
     (*note Files::.).

`help target NAME'
     Describe a particular target, including any parameters necessary
     to select it.

   Here are some common targets (available, or not, depending on the
GDB configuration):

`target exec PROG'
     An executable file.  `target exec PROG' is the same as
     `exec-file PROG'.

`target core FILENAME'
     A core dump file.  `target core FILENAME' is the same as
     `core-file FILENAME'.

`target remote DEV'
     Remote serial target in GDB-specific protocol.  The argument DEV
     specifies what serial device to use for the connection (e.g. 
     `/dev/ttya'). *Note Remote::.

`target amd-eb DEV SPEED PROG'
     Remote PC-resident AMD EB29K board, attached over serial lines. 
     DEV is the serial device, as for `target remote'; SPEED allows
     you to specify the linespeed; and PROG is the name of the
     program to be debugged, as it appears to DOS on the PC.  *Note
     EB29K Remote::.

`target nindy DEVICENAME'
     An Intel 960 board controlled by a Nindy Monitor.  DEVICENAME is
     the name of the serial device to use for the connection, e.g. 
     `/dev/ttya'.  *Note i960-Nindy Remote::.

`target vxworks MACHINENAME'
     A VxWorks system, attached via TCP/IP.  The argument MACHINENAME
     is the target system's machine name or IP address.  *Note
     VxWorks Remote::.

   Different targets are available on different configurations of
GDB; your configuration may have more or fewer targets.


File: gdb.info,  Node: Remote,  Prev: Target Commands,  Up: Targets

Remote Debugging
================

* Menu:

* i960-Nindy Remote::		
* EB29K Remote::		
* VxWorks Remote::		

   If you are trying to debug a program running on a machine that
can't run GDB in the usual way, it is often useful to use remote
debugging.  For example, you might use remote debugging on an
operating system kernel, or on a small system which does not have a
general purpose operating system powerful enough to run a
full-featured debugger.

   Some configurations of GDB have special serial or TCP/IP
interfaces to make this work with particular debugging targets.  In
addition,
GDB comes with a generic serial protocol (specific to GDB, but not
specific to any particular target system) which you can use if you
write the remote stubs--the code that will run on the remote system
to
communicate
with GDB.

   To use the GDB remote serial protocol, the program to be debugged
on the remote machine needs to contain a debugging stub which talks
to GDB over the serial line.  Several working remote stubs are
distributed with GDB; see the `README' file in the GDB distribution
for more information.

   For details of this communication protocol, see the comments in
the GDB source file `remote.c'.

   To start remote debugging, first run GDB and specify as an
executable file the program that is running in the remote machine. 
This tells GDB how to find the program's symbols and the contents of
its pure text.  Then establish communication using the `target
remote' command with a device name as an argument.  For example:

     target remote /dev/ttyb

if the serial line is connected to the device named `/dev/ttyb'. 
This will stop the remote machine if it is not already stopped.

   Now you can use all the usual commands to examine and change data
and to step and continue the remote program.

   To resume the remote program and stop debugging it, use the
`detach' command.

   Other remote targets may be available in your configuration of
GDB; use `help targets' to list them.


File: gdb.info,  Node: i960-Nindy Remote,  Next: EB29K Remote,  Prev: Remote,  Up: Remote

GDB with a Remote i960 (Nindy)
------------------------------

   "Nindy" is a ROM Monitor program for Intel 960 target systems. 
When GDB is configured to control a remote Intel 960 using Nindy,
you can tell GDB how to connect to the 960 in several ways:

   * Through command line options specifying serial port, version of
     the Nindy protocol, and communications speed;

   * By responding to a prompt on startup;

   * By using the `target' command at any point during your GDB
     session.  *Note Target Commands::.

* Menu:

* Nindy Startup::		Startup with Nindy
* Nindy Options::		Options for Nindy
* Nindy reset::			Nindy Reset Command


File: gdb.info,  Node: Nindy Startup,  Next: Nindy Options,  Prev: i960-Nindy Remote,  Up: i960-Nindy Remote

Startup with Nindy
..................

   If you simply start `GDB' without using any command-line options,
you are prompted for what serial port to use, *before* you reach the
ordinary GDB prompt:

     Attach /dev/ttyNN -- specify NN, or "quit" to quit:

Respond to the prompt with whatever suffix (after `/dev/tty')
identifies the serial port you want to use.  You can, if you choose,
simply start up with no Nindy connection by responding to the prompt
with an empty line.  If you do this, and later wish to attach to
Nindy, use `target' (*note Target Commands::.).


File: gdb.info,  Node: Nindy Options,  Next: Nindy reset,  Prev: Nindy Startup,  Up: i960-Nindy Remote

Options for Nindy
.................

   These are the startup options for beginning your GDB session with
a Nindy-960 board attached:

`-r PORT'
     Specify the serial port name of a serial interface to be used to
     connect to the target system.  This option is only available
     when GDB is configured for the Intel 960 target architecture. 
     You may specify PORT as any of: a full pathname (e.g. `-r
     /dev/ttya'), a device name in `/dev' (e.g. `-r ttya'), or
     simply
     the unique suffix for a specific `tty' (e.g. `-r a').

`-O'
     (An uppercase letter "O", not a zero.)  Specify that GDB should
     use the "old" Nindy monitor protocol to connect to the target
     system.  This option is only available when GDB is configured
     for the Intel 960 target architecture.

          *Warning:* if you specify `-O', but are actually trying to
          connect to a target system that expects the newer
          protocol, the connection will fail, appearing to be a
          speed mismatch.  GDB will repeatedly attempt to reconnect
          at several different line speeds.  You can abort this
         
          process with an interrupt.

`-brk'
     Specify that GDB should first send a `BREAK' signal to the
     target system, in an attempt to reset it, before connecting to
     a Nindy target.

          *Warning:* Many target systems do not have the hardware
          that this requires; it only works with a few boards.

   The standard `-b' option controls the line speed used on the
serial port.


File: gdb.info,  Node: Nindy reset,  Prev: Nindy Options,  Up: i960-Nindy Remote

Nindy Reset Command
...................

`reset'
     For a Nindy target, this command sends a "break" to the remote
     target system; this is only useful if the target has been
     equipped with a circuit to perform a hard reset (or some other
     interesting action) when a break is detected.


File: gdb.info,  Node: EB29K Remote,  Next: VxWorks Remote,  Prev: i960-Nindy Remote,  Up: Remote

GDB with a Remote EB29K
-----------------------

   To use GDB from a Unix system to run programs on AMD's EB29K board
in a PC, you must first connect a serial cable between the PC and a
serial port on the Unix system.  In the following, we assume you've
hooked the cable between the PC's `COM1' port and `/dev/ttya' on the
Unix system.

* Menu:

* Comms (EB29K)::		Communications Setup
* gdb-EB29K::			EB29K cross-debugging
* Remote Log::			Remote Log


File: gdb.info,  Node: Comms (EB29K),  Next: gdb-EB29K,  Prev: EB29K Remote,  Up: EB29K Remote

Communications Setup
....................

   The next step is to set up the PC's port, by doing something like
the following in DOS on the PC:

     C:\> MODE com1:9600,n,8,1,none

This example--run on an MS DOS 4.0 system--sets the PC port to 9600
bps, no parity, eight data bits, one stop bit, and no "retry"
action; you must match the communications parameters when
establishing the Unix end of the connection as well.

   To give control of the PC to the Unix side of the serial line,
type the following at the DOS console:

     C:\> CTTY com1

(Later, if you wish to return control to the DOS console, you can use
the command `CTTY con'--but you must send it over the device that
had control, in our example over the `COM1' serial line).

   From the Unix host, use a communications program such as `tip' or
`cu' to communicate with the PC; for example,

     cu -s 9600 -l /dev/ttya

The `cu' options shown specify, respectively, the linespeed and the
serial port to use.  If you use `tip' instead, your command line may
look something like the following:

     tip -9600 /dev/ttya

Your system may define a different name where our example uses
`/dev/ttya' as the argument to `tip'.  The communications
parameters, including what port to use, are associated with the
`tip' argument in the "remote" descriptions file--normally the
system table `/etc/remote'.

   Using the `tip' or `cu' connection, change the DOS working
directory to the directory containing a copy of your 29K program,
then start the PC program `EBMON' (an EB29K control program supplied
with your board by AMD).  You should see an initial display from
`EBMON' similar to the one that follows, ending with the `EBMON'
prompt `#'--

     C:\> G:
     
     G:\> CD \usr\joe\work29k
     
     G:\USR\JOE\WORK29K> EBMON
     Am29000 PC Coprocessor Board Monitor, version 3.0-18
     Copyright 1990 Advanced Micro Devices, Inc.
     Written by Gibbons and Associates, Inc.
     
     Enter '?' or 'H' for help
     
     PC Coprocessor Type   = EB29K
     I/O Base              = 0x208
     Memory Base           = 0xd0000
     
     Data Memory Size      = 2048KB
     Available I-RAM Range = 0x8000 to 0x1fffff
     Available D-RAM Range = 0x80002000 to 0x801fffff
     
     PageSize              = 0x400
     Register Stack Size   = 0x800
     Memory Stack Size     = 0x1800
     
     CPU PRL               = 0x3
     Am29027 Available     = No
     Byte Write Available  = Yes
     
     # ~.

   Then exit the `cu' or `tip' program (done in the example by typing
`~.' at the `EBMON' prompt).  `EBMON' will keep running, ready for
GDB to take over.

   For this example, we've assumed what is probably the most
convenient way to make sure the same 29K program is on both the PC
and the Unix system: a PC/NFS connection that establishes "drive
`G:'" on the PC as a file system on the Unix host.  If you don't
have PC/NFS or something similar connecting the two systems, you
must arrange some other way--perhaps floppy-disk transfer--of
getting
the 29K program from the Unix system to the PC; GDB will *not*
download it over the serial line.


File: gdb.info,  Node: gdb-EB29K,  Next: Remote Log,  Prev: Comms (EB29K),  Up: EB29K Remote

EB29K cross-debugging
.....................

   Finally, `cd' to the directory containing an image of your 29K
program on the Unix system, and start GDB--specifying as argument
the name of your 29K program:

     cd /usr/joe/work29k
     gdb myfoo

   Now you can use the `target' command:

     target amd-eb /dev/ttya 9600 MYFOO

In this example, we've assumed your program is in a file called
`myfoo'.  Note that the filename given as the last argument to
`target amd-eb' should be the name of the program as it appears to
DOS.  In our example this is simply `MYFOO', but in general it can
include a DOS path, and depending on your transfer mechanism may not
resemble the name on the Unix side.

   At this point, you can set any breakpoints you wish; when you're
ready to see your program run on the 29K board, use the GDB command
`run'.

   To stop debugging the remote program, use the GDB `detach'
command.

   To return control of the PC to its console, use `tip' or `cu' once
again,
after your GDB session has concluded, to attach to `EBMON'.  You can
then type the command `q' to shut down `EBMON', returning control to
the DOS command-line interpreter.  Type `CTTY con' to return command
input to the main DOS console, and type `~.' to leave `tip' or `cu'.


File: gdb.info,  Node: Remote Log,  Prev: gdb-EB29K,  Up: EB29K Remote

Remote Log
..........

   The `target amd-eb' command creates a file `eb.log' in the current
working directory, to help debug problems with the connection. 
`eb.log' records all the output from `EBMON', including echoes of
the commands sent to it.  Running `tail -f' on this file in another
window often helps to understand trouble with `EBMON', or unexpected
events on the PC side of the connection.


File: gdb.info,  Node: VxWorks Remote,  Prev: EB29K Remote,  Up: Remote

GDB and VxWorks
---------------

   GDB enables developers to spawn and debug tasks running on
networked VxWorks targets from a Unix host.  Already-running tasks
spawned from the VxWorks shell can also be debugged.  GDB uses code
that
runs on both the UNIX host and on the VxWorks target.  The program
`gdb' is installed and executed on the UNIX host.

   The remote debugging interface (RDB) routines are installed and
executed on the VxWorks target.  These routines are included in the
VxWorks library `rdb.a' and are incorporated into the system image
when source-level debugging is enabled in the VxWorks configuration.

   Defining `INCLUDE_RDB' in the VxWorks configuration file
`configAll.h' includes the RDB interface routines and spawns the
source debugging task `tRdbTask' when VxWorks is booted.  For more
information on configuring and remaking VxWorks, see the `VxWorks
Programmer's Guide'.

   Once you have included the RDB interface in your VxWorks system
image and set your Unix execution search path to find GDB, you are
ready to run GDB.  From your UNIX host, type:

     % gdb

   GDB will come up showing the prompt:

     (gdb)

* Menu:

* VxWorks connection::		Connecting to VxWorks
* VxWorks download::		VxWorks Download
* VxWorks attach::		Running Tasks


File: gdb.info,  Node: VxWorks connection,  Next: VxWorks download,  Prev: VxWorks Remote,  Up: VxWorks Remote

Connecting to VxWorks
.....................

   The GDB command `target' lets you connect to a VxWorks target on
the network.  To connect to a target whose host name is "`tt'", type:

     (gdb) target vxworks tt

   GDB will display a message similar to the following:

     Attaching remote machine across net... Success!

   GDB will then attempt to read the symbol tables of any object
modules loaded into the VxWorks target since it was last booted. 
GDB locates these files by searching the directories listed in the
command search path (*note Environment::.); if it fails to find an
object file, it will display a message such as:

     prog.o: No such file or directory.

   This will cause the `target' command to abort.  When this happens,
you should add the appropriate directory to the search path, with
the GDB command `path', and execute the `target' command again.


File: gdb.info,  Node: VxWorks download,  Next: VxWorks attach,  Prev: VxWorks connection,  Up: VxWorks Remote

VxWorks Download
................

   If you have connected to the VxWorks target and you want to debug
an object that has not yet been loaded, you can use the GDB `load'
command to download a file from UNIX to VxWorks incrementally.  The
object file given as an argument to the `load' command is actually
opened twice: first by the VxWorks target in order to download the
code, then by GDB in order to read the symbol table.  This can lead
to problems if the current working directories on the two systems
differ.  It is simplest to set the working directory on both systems
to the directory in which the object file resides, and then to
reference the file by its name, without any path.  Thus, to load a
program `prog.o', residing in `wherever/vw/demo/rdb', on VxWorks type:

     -> cd "wherever/vw/demo/rdb"

   On GDB type:

     (gdb) cd wherever/vw/demo/rdb 
     (gdb) load prog.o

   GDB will display a response similar to the following:

     Reading symbol data from wherever/vw/demo/rdb/prog.o... done.

   You can also use the `load' command to reload an object module
after
editing and recompiling the corresponding source file.  Note that
this will cause GDB to delete all currently-defined breakpoints,
auto-displays, and convenience variables, and to clear the value
history.  (This is necessary in order to preserve the integrity of
debugger data structures that reference the target system's symbol
table.)


File: gdb.info,  Node: VxWorks attach,  Prev: VxWorks download,  Up: VxWorks Remote

Running Tasks
.............

   You can also attach to an existing task using the `attach' command
as follows:

     (gdb) attach TASK

   where TASK is the VxWorks hexadecimal task ID.  The task can be
running or suspended when you attach to it.  If running, it will be
suspended
at the time of attachment.


File: gdb.info,  Node: Controlling GDB,  Next: Sequences,  Prev: Targets,  Up: Top

Controlling GDB
***************

   You can alter many aspects of GDB's interaction with you by using
the `set' command.  For commands controlling how GDB displays data,
*note Print Settings::.; other settings are described here.

* Menu:

* Prompt::			Prompt
* Editing::			Command Editing
* History::			Command History
* Screen Size::			Screen Size
* Numbers::			Numbers
* Messages/Warnings::		Optional Warnings and Messages


File: gdb.info,  Node: Prompt,  Next: Editing,  Prev: Controlling GDB,  Up: Controlling GDB

Prompt
======

   GDB indicates its readiness to read a command by printing a string
called the "prompt".  This string is normally `(gdb)'.  You can
change
the prompt string with the `set prompt' command.  For instance, when
debugging GDB with GDB, it is useful to change the prompt in one of
the GDBs so that you can always tell which one you are talking to.

`set prompt NEWPROMPT'
     Directs GDB to use NEWPROMPT as its prompt string henceforth.

`show prompt'
     Prints a line of the form: `Gdb's prompt is: YOUR-PROMPT'


File: gdb.info,  Node: Editing,  Next: History,  Prev: Prompt,  Up: Controlling GDB

Command Editing
===============

   GDB reads its input commands via the "readline" interface.  This
GNU library provides consistent behavior for programs which provide
a command line interface to the user.  Advantages are `emacs'-style
or `vi'-style inline editing of commands, `csh'-like history
substitution, and a storage and recall of command history across
debugging sessions.

   You may control the behavior of command line editing in GDB with
the command `set'.

`set editing'
`set editing on'
     Enable command line editing (enabled by default).

`set editing off'
     Disable command line editing.

`show editing'
     Show whether command line editing is enabled.


File: gdb.info,  Node: History,  Next: Screen Size,  Prev: Editing,  Up: Controlling GDB

Command History
===============

`set history filename FNAME'
     Set the name of the GDB command history file to FNAME.  This is
     the file from which GDB will read an initial command history
     list or to which it will write this list when it exits.  This
     list is accessed through history expansion or through the
     history command editing characters listed below.  This file
     defaults to the value of the environment variable
     `GDBHISTFILE', or to `./.gdb_history' if this variable is not
     set.

`set history save'
`set history save on'
     Record command history in a file, whose name may be specified
     with the `set history filename' command.  By default, this
     option is disabled.

`set history save off'
     Stop recording command history in a file.

`set history size SIZE'
     Set the number of commands which GDB will keep in its history
     list.  This defaults to the value of the environment variable
     `HISTSIZE', or to 256 if this variable is not set.

   History expansion assigns special meaning to the character `!'. 
Since `!' is also the logical not operator in C, history expansion
is off by default. If you decide to enable history expansion with
the `set history expansion on' command, you may sometimes need to
follow `!' (when it is used as logical not, in an expression) with a
space or a tab to prevent it from being expanded.  The readline
history facilities will not attempt substitution on the strings `!='
and `!(', even when history expansion is enabled.

   The commands to control history expansion are:

`set history expansion on'
`set history expansion'
     Enable history expansion.  History expansion is off by default.

`set history expansion off'
     Disable history expansion.

     The readline code comes with more complete documentation of
     editing and history expansion features.  Users unfamiliar with
     `emacs' or `vi' may wish to read it.

`show history'
`show history filename'
`show history save'
`show history size'
`show history expansion'
     These commands display the state of the GDB history parameters. 
     `show history' by itself displays all four states.

`show commands'
     Display the last ten commands in the command history.

`show commands N'
     Print ten commands centered on command number N.

`show commands +'
     Print ten commands just after the commands last printed.


File: gdb.info,  Node: Screen Size,  Next: Numbers,  Prev: History,  Up: Controlling GDB

Screen Size
===========

   Certain commands to GDB may produce large amounts of information
output to the screen.  To help you read all of it, GDB pauses and
asks you for input at the end of each page of output.  Type RET when
you want to continue the output.  GDB also uses the screen width
setting to determine when to wrap lines of output.  Depending on
what is being printed, it tries to break the line at a readable
place, rather than simply letting it overflow onto the following line.

   Normally GDB knows the size of the screen from the termcap data
base together with the value of the `TERM' environment variable and
the `stty rows' and `stty cols' settings. If this is not correct,
you can override it with the `set height' and `set width' commands:

`set height LPP'
`show height'
`set width CPL'
`show width'
     These `set' commands specify a screen height of LPP lines and a
     screen width of CPL characters.  The associated `show' commands
     display the current settings.

     If you specify a height of zero lines, GDB will not pause during
     output no matter how long the output is.  This is useful if
     output is to a file or to an editor buffer.


File: gdb.info,  Node: Numbers,  Next: Messages/Warnings,  Prev: Screen Size,  Up: Controlling GDB

Numbers
=======

   You can always enter numbers in octal, decimal, or hexadecimal in
GDB by the usual conventions: octal numbers begin with `0', decimal
numbers end with `.', and hexadecimal numbers begin with `0x'. 
Numbers that begin with none of these are, by default, entered in
base 10; likewise, the default display for numbers--when no
particular format is specified--is base 10.  You can change the
default base for both input and output with the `set radix' command.

`set radix BASE'
     Set the default base for numeric input and display.  Supported
     choices for BASE are decimal 8, 10, 16.  BASE must itself be
     specified either unambiguously or using the current default
     radix; for example, any of

          set radix 012
          set radix 10.
          set radix 0xa

     will set the base to decimal.  On the other hand, `set radix 10'
    
     will leave the radix unchanged no matter what it was.

`show radix'
     Display the current default base for numeric input and display.


File: gdb.info,  Node: Messages/Warnings,  Prev: Numbers,  Up: Controlling GDB

Optional Warnings and Messages
==============================

   By default, GDB is silent about its inner workings.  If you are
running on a slow machine, you may want to use the `set verbose'
command.  It will make GDB tell you when it does a lengthy internal
operation, so you won't think it has crashed.

   Currently, the messages controlled by `set verbose' are those
which announce that the symbol table for a source file is being read
(*note Files::., in the description of the command `symbol-file').

`set verbose on'
     Enables GDB's output of certain informational messages.

`set verbose off'
     Disables GDB's output of certain informational messages.

`show verbose'
     Displays whether `set verbose' is on or off.

   By default, if GDB encounters bugs in the symbol table of an
object file, it prints a single message about each type of problem
it finds, then  shuts up (*note Symbol Errors::.).  You can suppress
these
messages, or allow more than one such message to be printed if you
want to see how frequent the problems are.

`set complaints LIMIT'
     Permits GDB to output LIMIT complaints about each type of
     unusual symbols before becoming silent about the problem.  Set
     LIMIT to zero to suppress all complaints; set it to a large
     number to prevent complaints from being suppressed.

`show complaints'
     Displays how many symbol complaints GDB is permitted to produce.

   By default, GDB is cautious, and asks what sometimes seem to be a
lot of stupid questions to confirm certain commands.  For example,
if you try to run a program which is already running:

     (gdb) run
     The program being debugged has been started already.
     Start it from the beginning? (y or n)

   If you're willing to unflinchingly face the consequences of your
own
commands, you can disable this "feature":

`set confirm off'
     Disables confirmation requests.

`set confirm on'
     Enables confirmation requests (the default).

`show confirm'
     Displays state of confirmation requests.


File: gdb.info,  Node: Sequences,  Next: Emacs,  Prev: Controlling GDB,  Up: Top

Canned Sequences of Commands
****************************

   Aside from breakpoint commands (*note Break Commands::.), GDB
provides two ways to store sequences of commands for execution as a
unit:
user-defined commands and command files.

* Menu:

* Define::			User-Defined Commands
* Command Files::		Command Files
* Output::			Commands for Controlled Output


File: gdb.info,  Node: Define,  Next: Command Files,  Prev: Sequences,  Up: Sequences

User-Defined Commands
=====================

   A "user-defined command" is a sequence of GDB commands to which
you assign a new name as a command.  This is done with the `define'
command.

`define COMMANDNAME'
     Define a command named COMMANDNAME.  If there is already a
     command by that name, you are asked to confirm that you want to
     redefine it.

     The definition of the command is made up of other GDB command
     lines, which are given following the `define' command.  The end
     of these commands is marked by a line containing `end'.

`document COMMANDNAME'
     Give documentation to the user-defined command COMMANDNAME.  The
     command COMMANDNAME must already be defined.  This command
     reads lines of documentation just as `define' reads the lines
     of the command definition, ending with `end'.  After the
     `document' command is finished, `help' on command COMMANDNAME
     will print the documentation you have specified.

     You may use the `document' command again to change the
     documentation of a command.  Redefining the command with
     `define' does not change the documentation.

`help user-defined'
     List all user-defined commands, with the first line of the
     documentation (if any) for each.

`info user'
`info user COMMANDNAME'
     Display the GDB commands used to define COMMANDNAME (but not its
     documentation).  If no COMMANDNAME is given, display the
     definitions for all user-defined commands.

   User-defined commands do not take arguments.  When they are
executed, the commands of the definition are not printed.  An error
in any command stops execution of the user-defined command.

   Commands that would ask for confirmation if used interactively
proceed without asking when used inside a user-defined command. 
Many GDB commands that normally print messages to say what they are
doing omit the messages when used in a user-defined command.


File: gdb.info,  Node: Command Files,  Next: Output,  Prev: Define,  Up: Sequences

Command Files
=============

   A command file for GDB is a file of lines that are GDB commands. 
Comments (lines starting with `#') may also be included.  An empty
line in a command file does nothing; it does not mean to repeat the
last command, as it would from the terminal.

   When you start GDB, it automatically executes commands from its
"init files".  These are files named `.gdbinit'.  GDB reads the init
file (if any) in your home directory and then the init file (if any)
in the current working directory.  (The init files are not executed
if you use the `-nx' option; *note Mode Options::..)  You can also
request the execution of a command file with the `source' command:

`source FILENAME'
     Execute the command file FILENAME.

   The lines in a command file are executed sequentially.  They are
not printed as they are executed.  An error in any command
terminates execution of the command file.

   Commands that would ask for confirmation if used interactively
proceed without asking when used in a command file.  Many GDB
commands that normally print messages to say what they are doing
omit the messages when called from command files.


File: gdb.info,  Node: Output,  Prev: Command Files,  Up: Sequences

Commands for Controlled Output
==============================

   During the execution of a command file or a user-defined command,
normal GDB output is suppressed; the only output that appears is
what is explicitly printed by the commands in the definition.  This
section describes three commands useful for generating exactly the
output
you want.

`echo TEXT'
     Print TEXT.  Nonprinting characters can be included in TEXT
     using C escape sequences, such as `\n' to print a newline.  No
     newline will be printed unless you specify one. In addition to
     the standard C escape sequences, a backslash followed by a
     space stands for a space.  This is useful for outputting a
     string with spaces at the beginning or the end, since leading
     and trailing spaces are otherwise trimmed from all arguments. 
     Thus, to print ` and foo = ', use the command `echo \ and foo =
     \ '.

     A backslash at the end of TEXT can be used, as in C, to continue
     the command onto subsequent lines.  For example,

          echo This is some text\n\
          which is continued\n\
          onto several lines.\n

     produces the same output as

          echo This is some text\n
          echo which is continued\n
          echo onto several lines.\n

`output EXPRESSION'
     Print the value of EXPRESSION and nothing but that value: no
     newlines, no `$NN = '.  The value is not entered in the value
     history either.  *Note Expressions:: for more information on
     expressions.

`output/FMT EXPRESSION'
     Print the value of EXPRESSION in format FMT.  You can use the
     same formats as for `print'; *note Output formats::., for more
     information.

`printf STRING, EXPRESSIONS...'
     Print the values of the EXPRESSIONS under the control of STRING.
     The EXPRESSIONS are separated by commas and may be either
     numbers or pointers.  Their values are printed as specified by
     STRING, exactly as if the program were to execute

          printf (STRING, EXPRESSIONS...);

     For example, you can print two values in hex like this:

          printf "foo, bar-foo = 0x%x, 0x%x\n", foo, bar-foo

     The only backslash-escape sequences that you can use in the
     format string are the simple ones that consist of backslash
     followed by a letter.

